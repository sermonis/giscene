<!DOCTYPE html>
<html lang="en">

    <head>

        <title>AVS - Track Race</title>
        <meta charset="utf-8">
    	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="../libs/three.js/examples/main.css">
		<!-- https://hofk.de/main/discourse.threejs/2019/js/THREEg.js -->

		<!-- <script src="https://hofk.de/main/discourse.threejs/2019/js/three.min.102.js"></script> -->
		<!-- <script src="https://hofk.de/main/discourse.threejs/2019/js/THREEg.js"></script>  -->
		<!--  geometry addon  -->
        <style></style>

    </head>

    <body>

        <div id="container"></div>

        <div id="info">

            <div>
                <a href="https://threejs.org" target="_blank" rel="noopener noreferrer">three.js</a> - Demonstrates track path following.
            </div>

            <div></div>

            <div id="message"></div>

        </div>

    </body>

    <script type="module">

        import * as THREE from '../libs/three.js/build/three.module.js';
        import Stats from '../libs/three.js/examples/jsm/libs/stats.module.js';
        import { GUI } from '../libs/three.js/examples/jsm/libs/dat.gui.module.js';

        import { OrbitControls } from '../libs/three.js/examples/jsm/controls/OrbitControls.js';
        // import { createRoad } from './js/libs/THREEg.jsm.js';
        // import THREEg2 from './js/libs/THREEg.jsm.js';// <!--  geometry addon  -->
        import { RoadSplineBufferGeometry } from './js/libs/THREEg.jsm.js';// <!--  geometry addon  -->
	    // import { GLTFLoader } from '../../lib/GLTFLoader.module.js';

        import Snapshot from './jsm/libs/snapshot.module.js';

        // ---------------------------------------------------------------------------

		const scene = new THREE.Scene();

		const camera = new THREE.PerspectiveCamera( 65, window.innerWidth / window.innerHeight, 0.01, 200 );
		camera.position.set( 0, 8, 16 );

		const renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setSize( window.innerWidth, window.innerHeight );
		// renderer.setClearColor( 0x11ff33, 1 );
		renderer.setClearColor( new THREE.Color( '#F2F5FA' ), 1 );

		const container = document.createElement( 'div' );
		document.body.appendChild( container );
		container.appendChild( renderer.domElement );

		const controls = new OrbitControls( camera, renderer.domElement );

		const clock = new THREE.Clock();

		const light = new THREE.AmbientLight( 0xffffff );

		scene.add( light );

		const gridHelper = new THREE.GridHelper( 30, 30 );
		scene.add( gridHelper );

		const curvePoints =  [
		 -6, 0, 10,
		 -1, 0, 10,
		  3, 0,  4,
		  6, 0,  1,
		 11, 0,  2,
		 13, 0,  6,
		  9, 1,  9,
		  4, 1,  7,
		  1, 1,  1,
		  0, 1, -5,
		  2, 0, -9,
		  8, 0,-10,
		 13, 0, -5,
		 14, 1,  2,
		 10, 3,  7,
		  2, 1,  8,
		 -4, 3,  7,
		 -8, 1,  1,
		 -9, 1, -4,
		 -6, 1, -9,
		  0, 1,-10,
		  7, 1, -7,
		  5, 2,  0,
		  0, 2,  2,
		 -5, 1,  0,
		 -7, 2, -5,
		 -8, 2, -9,
		-11, 2, -10,
		-14, 1, -7,
		-13, 1, -2,
		-14, 0,  3,
		-11, 0, 10,
		 -6, 0, 10
		];


		const lengthSegments = 1000;
		const trackDistances = [ -0.31, -0.3, -0.01, 0.01, 0.3, 0.31 ];

		// var gRoad = new THREE.BufferGeometry( );
		// const roadGeometry = new RoadSplineBufferGeometry( curvePoints, lengthSegments, trackDistances );
		const gRoad = new RoadSplineBufferGeometry( curvePoints, lengthSegments, trackDistances );
		// var gRoad = new RoadSplineBufferGeometry();
		// gRoad.createRoad();

		// const roadGeometry = gRoad.createRoad( curvePoints, lengthSegments, trackDistances );
		// gRoad.createRoad = THREEg.createRoad;
		// gRoad.createRoad = createRoad;
		// gRoad.createRoad( curvePoints, lengthSegments, trackDistances );
		//gRoad.createRoad( ); // all parameters default

		const tex = new THREE.TextureLoader().load( 'textures/roads/road-central-marking.png' );
		tex.wrapS = THREE.RepeatWrapping;
		// tex.wrapT = THREE.RepeatWrapping;
		tex.repeat.set( lengthSegments * 2 );

		// TODO: Multimaterial.
		const material = [

			new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide  } ),
			new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.DoubleSide  } ),
			new THREE.MeshBasicMaterial( { map: tex, side: THREE.DoubleSide } ),
			new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } ),
			new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide } ),

		];

		const mesh = new THREE.Mesh( gRoad, material );
		// // var mesh = new THREE.Mesh( roadGeometry, material );
		scene.add( mesh );

		var h = 0.08;
		var redCar = new THREE.Mesh(
			new THREE.BoxBufferGeometry( 0.1, h * 1.9 , 0.3 ),
			new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.DoubleSide, wireframe: true } )
		);

		scene.add( redCar );

		var redCarIdx = 0;
		var redCarX, redCarY, redCarZ;

		var blueCar = new THREE.Mesh(
			new THREE.BoxBufferGeometry( 0.12, h * 1.9, 0.4 ),
			new THREE.MeshBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide, wireframe: true  } )
		);
		scene.add( blueCar );

		var blueCarIdx = gRoad.points.length - 1;
		var blueCarX, blueCarY, blueCarZ;

		// THREE.StaticDrawUsage
		// THREE.DynamicDrawUsage
		// .setUsage( THREE.DynamicDrawUsage )

		var gTngt = new THREE.BufferGeometry( ); // tangent
		gTngt.positions = new Float32Array( 6 );
		gTngt.setAttribute( 'position', new THREE.BufferAttribute( gTngt.positions, 3 ).setUsage( THREE.DynamicDrawUsage ) );

		const lineTngt = new THREE.Line( gTngt, new THREE.LineBasicMaterial( { color: 0x00ffff, side: THREE.DoubleSide } ) );
		scene.add( lineTngt );

		var gNorm = new THREE.BufferGeometry( ); // normal
		gNorm.positions = new Float32Array( 6 );
		gNorm.setAttribute( 'position', new THREE.BufferAttribute( gNorm.positions, 3 ).setUsage( THREE.DynamicDrawUsage ) );

		const lineNorm = new THREE.Line( gNorm, new THREE.LineBasicMaterial( { color: 0xff0000, side: THREE.DoubleSide } ) );
		scene.add( lineNorm );

		var gBino = new THREE.BufferGeometry( ); // binormal
		gBino.positions = new Float32Array( 6 );
		gBino.setAttribute( 'position', new THREE.BufferAttribute( gBino.positions, 3 ).setUsage( THREE.DynamicDrawUsage ) );

		const lineBino = new THREE.Line( gBino, new THREE.LineBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide } ) );
		scene.add( lineBino );

		var sysIdx = 8;

		var t1 = 0;
		var t2;

		animate();

		//............................

		function animate () {

			t2 = clock.getElapsedTime ( );

			requestAnimationFrame( animate );
			renderer.render( scene, camera );

			if ( t2 - t1 > 0.04 ) {

				redCarX = gRoad.points[ redCarIdx ].x + gRoad.n[ redCarIdx ].x * trackDistances[ 4 ] * 0.6;
				redCarY = gRoad.points[ redCarIdx ].y + h;
				redCarZ = gRoad.points[ redCarIdx ].z + gRoad.n[ redCarIdx ].z * trackDistances[ 4 ] * 0.6;

				redCar.position.set( redCarX, redCarY, redCarZ );

				redCar.rotation.y = 1.57 + Math.atan2( -gRoad.t[ redCarIdx ].z, gRoad.t[ redCarIdx ].x );
				// other: take tangent, binormal for calculation

				redCarIdx ++;

				if ( redCarIdx === gRoad.points.length  ) redCarIdx = 0;

				blueCarX = gRoad.points[ blueCarIdx ].x + gRoad.n[ blueCarIdx ].x * trackDistances[ 1 ] * 0.6;
				blueCarY = gRoad.points[ blueCarIdx ].y + h;
				blueCarZ = gRoad.points[ blueCarIdx ].z + gRoad.n[ blueCarIdx ].z * trackDistances[ 1 ] * 0.6;

				blueCar.position.set( blueCarX, blueCarY, blueCarZ );

				blueCar.rotation.y = 1.57 + Math.atan2( -gRoad.t[ blueCarIdx ].z, gRoad.t[ blueCarIdx ].x );
				// other: take tangent, binormal for calculation

				blueCarIdx --;

				if ( blueCarIdx === -1  ) blueCarIdx = gRoad.points.length - 1;

				gTngt.positions[ 0 ] = gRoad.points[ sysIdx ].x;  // tangent
				gTngt.positions[ 1 ] = gRoad.points[ sysIdx ].y;
				gTngt.positions[ 2 ] = gRoad.points[ sysIdx ].z;

				gTngt.positions[ 3 ] = gRoad.points[ sysIdx ].x + gRoad.t[ sysIdx ].x;
				gTngt.positions[ 4 ] = gRoad.points[ sysIdx ].y + gRoad.t[ sysIdx ].y;
				gTngt.positions[ 5 ] = gRoad.points[ sysIdx ].z + gRoad.t[ sysIdx ].z;

				gTngt.attributes.position.needsUpdate = true;

				gNorm.positions[ 0 ] = gRoad.points[ sysIdx ].x; // normal
				gNorm.positions[ 1 ] = gRoad.points[ sysIdx ].y;
				gNorm.positions[ 2 ] = gRoad.points[ sysIdx ].z;

				gNorm.positions[ 3 ] = gRoad.points[ sysIdx ].x + gRoad.n[ sysIdx ].x;
				gNorm.positions[ 4 ] = gRoad.points[ sysIdx ].y + gRoad.n[ sysIdx ].y;
				gNorm.positions[ 5 ] = gRoad.points[ sysIdx ].z + gRoad.n[ sysIdx ].z;

				gNorm.attributes.position.needsUpdate = true;

				gBino.positions[ 0 ] = gRoad.points[ sysIdx ].x; // binormal
				gBino.positions[ 1 ] = gRoad.points[ sysIdx ].y;
				gBino.positions[ 2 ] = gRoad.points[ sysIdx ].z;

				gBino.positions[ 3 ] = gRoad.points[ sysIdx ].x + gRoad.b[ sysIdx ].x;
				gBino.positions[ 4 ] = gRoad.points[ sysIdx ].y + gRoad.b[ sysIdx ].y;
				gBino.positions[ 5 ] = gRoad.points[ sysIdx ].z + gRoad.b[ sysIdx ].z;

				gBino.attributes.position.needsUpdate = true;

				sysIdx ++;

				if ( sysIdx === gRoad.points.length  ) {

					sysIdx = 0;

				}

				t1 = t2;

			}

			controls.update();

		}

        // ---------------------------------------------------------------------------

		// let renderer, scene, camera, helper, stats;
		//
		// const points = [];
		//
		// const params = {
		//
		// 	boundingVolume: 'None',
		//
		// };
		//
        // init();
        // meshup();
		// tune();
        // animate();
		//
		// function init () {
		//
		// 	scene = new THREE.Scene();
		// 	scene.background = new THREE.Color( 0xa0a0a0 );
		// 	scene.fog = new THREE.Fog( 0xa0a0a0, 20, 200 );
		//
		// 	camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 250 );
		// 	camera.position.set( 10, 10, 30 );
		//
		// 	//
		//
		// 	const geometry = new THREE.PlaneBufferGeometry( 500, 500 );
		// 	const material = new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } );
		//
		// 	const ground = new THREE.Mesh( geometry, material );
		// 	ground.rotation.x = - Math.PI / 2;
		// 	ground.matrixAutoUpdate = false;
		// 	ground.receiveShadow = true;
		// 	ground.updateMatrix();
		// 	scene.add( ground );
		//
		// 	//
		//
		// 	const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 0.6 );
		// 	hemiLight.position.set( 0, 100, 0 );
		// 	hemiLight.matrixAutoUpdate = false;
		// 	hemiLight.updateMatrix();
		// 	scene.add( hemiLight );
		//
		// 	const dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
		// 	dirLight.position.set( - 40, 50, 50 );
		// 	dirLight.matrixAutoUpdate = false;
		// 	dirLight.updateMatrix();
		// 	dirLight.castShadow = true;
		// 	dirLight.shadow.camera.top = 25;
		// 	dirLight.shadow.camera.bottom = - 25;
		// 	dirLight.shadow.camera.left = - 25;
		// 	dirLight.shadow.camera.right = 25;
		// 	dirLight.shadow.camera.near = 1;
		// 	dirLight.shadow.camera.far = 200;
		// 	dirLight.shadow.mapSize.x = 2048;
		// 	dirLight.shadow.mapSize.y = 2048;
		// 	scene.add( dirLight );
		//
		// 	// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );
		//
		// 	// MODEL ...
		//
		// 	// THREE.LinearEncoding // default
		// 	// THREE.sRGBEncoding
		// 	// THREE.GammaEncoding
		// 	// THREE.RGBEEncoding
		// 	// THREE.LogLuvEncoding
		// 	// THREE.RGBM7Encoding
		// 	// THREE.RGBM16Encoding
		// 	// THREE.RGBDEncoding
		// 	// THREE.BasicDepthPacking
		// 	// THREE.RGBADepthPacking
		//
		// 	renderer = new THREE.WebGLRenderer( { antialias: true } );
		// 	renderer.setPixelRatio( window.devicePixelRatio );
		// 	renderer.setSize( window.innerWidth, window.innerHeight );
		// 	renderer.outputEncoding = THREE.sRGBEncoding;
		// 	renderer.shadowMap.enabled = true;
		// 	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		// 	document.body.appendChild( renderer.domElement );
		//
		// 	//
		//
		// 	window.addEventListener( 'resize', onWindowResize, false );
		//
		// 	const controls = new OrbitControls( camera, renderer.domElement );
		// 	controls.enablePan = false;
		// 	controls.minDistance = 10;
		// 	controls.maxDistance = 50;
		// 	controls.target.set( 0.5, 8, 2.5 );
		// 	controls.update();
		//
		// }
		//
		// function meshup () {
		//
		// 	// const gridHelper = new THREE.GridHelper( 30, 30 );
		// 	// scene.add( gridHelper );
		// 	//
		// 	// const curvePoints =  [
		// 	//
		// 	// 	-6, 0, 10,
		// 	// 	-1, 0, 10,
		// 	// 	3, 0,  4,
		// 	// 	6, 0,  1,
		// 	// 	11, 0,  2,
		// 	// 	13, 0,  6,
		// 	// 	9, 1,  9,
		// 	// 	4, 1,  7,
		// 	// 	1, 1,  1,
		// 	// 	0, 1, -5,
		// 	// 	2, 0, -9,
		// 	// 	8, 0,-10,
		// 	// 	13, 0, -5,
		// 	// 	14, 1,  2,
		// 	// 	10, 3,  7,
		// 	// 	2, 1,  8,
		// 	// 	-4, 3,  7,
		// 	// 	-8, 1,  1,
		// 	// 	-9, 1, -4,
		// 	// 	-6, 1, -9,
		// 	// 	0, 1,-10,
		// 	// 	7, 1, -7,
		// 	// 	5, 2,  0,
		// 	// 	0, 2,  2,
		// 	// 	-5, 1,  0,
		// 	// 	-7, 2, -5,
		// 	// 	-8, 2, -9,
		// 	// 	-11, 2, -10,
		// 	// 	-14, 1, -7,
		// 	// 	-13, 1, -2,
		// 	// 	-14, 0,  3,
		// 	// 	-11, 0, 10,
		// 	// 	-6, 0, 10
		// 	//
		// 	// ];
		// 	//
		// 	// const lengthSegments = 1000;
		// 	// const trackDistances = [ -0.31, -0.3, -0.01, 0.01, 0.3, 0.31 ];
		// 	//
		// 	// const gRoad = new THREE.BufferGeometry();
		// 	// // gRoad.createRoad = THREEg.createRoad;
		// 	// gRoad.createRoad = createRoad;
		// 	// gRoad.createRoad( curvePoints, lengthSegments, trackDistances );
		// 	// //gRoad.createRoad( ); // all parameters default
		// 	//
		// 	// // road-central-marking.png
		// 	//
		// 	// tex = new THREE.TextureLoader().load( 'textures/roads/road-central-marking.png' );
		// 	// tex.wrapS = THREE.RepeatWrapping;
		// 	// //tex.wrapT = THREE.RepeatWrapping;
		// 	// tex.repeat.set( lengthSegments * 2 );
		// 	//
		// 	// var material = [
		// 	//
		// 	// 	new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide  } ),
		// 	// 	new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.DoubleSide  } ),
		// 	// 	new THREE.MeshBasicMaterial( { map: tex, side: THREE.DoubleSide } ),
		// 	// 	new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.DoubleSide} ),
		// 	// 	new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide} ),
		// 	//
		// 	// ];
		// 	//
		// 	// var mesh = new THREE.Mesh( gRoad, material );
		// 	// scene.add( mesh );
		// 	//
		// 	// var h = 0.08;
		// 	// var redCar = new THREE.Mesh(
		// 	// new THREE.BoxBufferGeometry( 0.1, h * 1.9 , 0.3 ),
		// 	// new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.DoubleSide, wireframe: true } )
		// 	// );
		// 	// scene.add( redCar );
		// 	// var redCarIdx = 0;
		// 	// var redCarX, redCarY, redCarZ;
		// 	//
		// 	// var blueCar = new THREE.Mesh(
		// 	// new THREE.BoxBufferGeometry( 0.12, h * 1.9, 0.4 ),
		// 	// new THREE.MeshBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide, wireframe: true  } )
		// 	// );
		// 	// scene.add( blueCar );
		// 	// var blueCarIdx = gRoad.points.length - 1;
		// 	// var blueCarX, blueCarY, blueCarZ;
		// 	//
		// 	// var gTngt = new THREE.BufferGeometry( ); // tangent
		// 	// gTngt.positions = new Float32Array( 6 );
		// 	// gTngt.addAttribute( 'position', new THREE.BufferAttribute( gTngt.positions, 3 ).setDynamic( true ) );
		// 	// lineTngt = new THREE.Line( gTngt, new THREE.LineBasicMaterial( { color: 0x00ffff, side: THREE.DoubleSide } ) );
		// 	// scene.add( lineTngt );
		// 	//
		// 	// var gNorm = new THREE.BufferGeometry( ); // normal
		// 	// gNorm.positions = new Float32Array( 6 );
		// 	// gNorm.addAttribute( 'position', new THREE.BufferAttribute( gNorm.positions, 3 ).setDynamic( true ) );
		// 	// lineNorm = new THREE.Line( gNorm, new THREE.LineBasicMaterial( { color: 0xff0000, side: THREE.DoubleSide } ) );
		// 	// scene.add( lineNorm );
		// 	//
		// 	// var gBino = new THREE.BufferGeometry( ); // binormal
		// 	// gBino.positions = new Float32Array( 6 );
		// 	// gBino.addAttribute( 'position', new THREE.BufferAttribute( gBino.positions, 3 ).setDynamic( true ) );
		// 	// lineBino = new THREE.Line( gBino, new THREE.LineBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide } ) );
		// 	// scene.add( lineBino );
		// 	//
		// 	// var sysIdx = 8;
		// 	//
		// 	// var t1 = 0;
		// 	// var t2;
		//
		// }
		//
		// function onWindowResize () {
		//
		// 	camera.aspect = window.innerWidth / window.innerHeight;
		// 	camera.updateProjectionMatrix();
		//
		// 	renderer.setSize( window.innerWidth, window.innerHeight );
		//
		// }
		//
		// function onTransitionEnd ( event ) {
		//
		// 	event.target.remove();
		//
		// }
		//
		// function animate () {
		//
		// 	requestAnimationFrame( animate );
		// 	renderer.render( scene, camera );
		//
		// 	stats.update();
		//
		// }
		//
		// // ---------------------------------------------------------------------------
		//
		// function tune () {
		//
		// 	// Init GUI.
		// 	setGUI();
		//
		// 	// Init Stats.
		// 	setStats();
		//
		// }
		//
        // function setGUI () {
		//
        //     // GUI params.
        // 	const params = {
		//
        //         // Snapshot width.
        //         width: 400,
		//
        //         // Snapshot height.
        //         height: 250,
		//
        //         // Download snapshot.
        //         takeShot: function () {
		//
        //             const snapshotRenderer = new THREE.WebGLRenderer( { antialias: true } );
        //             snapshotRenderer.setSize( params.width, params.height );
		//
        //             const snapshot = new Snapshot( snapshotRenderer ).capture( scene, camera );
        //             snapshotRenderer.dispose();
		//
        //         },
		//
        //     };
		//
        //     const gui = new GUI();
		//
        //     const snapshotFolder = gui.addFolder( 'Snapshot' );
		//
        //     snapshotFolder.add( params, 'width', 0, 2200, 50 );
        //     snapshotFolder.add( params, 'height', 0, 1329, 50 );
        //     snapshotFolder.add( params, 'takeShot' );
		//
        // 	snapshotFolder.open();
		//
        //     gui.close();
		//
        // }
		//
		// function setStats () {
		//
        //     stats = new Stats();
        //     stats.domElement.style.position = 'absolute';
        //     stats.domElement.style.bottom = '0px';
        //     stats.domElement.style.zIndex = 100;
        //     document.body.appendChild( stats.domElement );
		//
        // }

    </script>

</html>
